#!/usr/bin/env python3
from os import environ
environ['CURL_CA_BUNDLE'] = ""
environ['REQUESTS_CA_BUNDLE'] = ""

import click
import requests
import sys
import json

from deezer import Deezer
from deezer import TrackFormats
from deemix.types.Track import Track
from deemix import generateDownloadObject, parseLink
from deemix.settings import DEFAULTS as DEFAULT_SETTINGS, load as loadSettings
from deemix.downloader import getPreferredBitrate, formatsName, streamTrack
from deemix.errors import DownloadFailed, MD5NotFound, DownloadCanceled, PreferredBitrateNotFound, TrackNot360, AlbumDoesntExists, DownloadError, ErrorMessages
from deezer.errors import WrongLicense, WrongGeolocation
from deemix.types.DownloadObjects import Single, Collection
from deemix.plugins.spotify import Spotify
import spotipy
SpotifyClientCredentials = spotipy.oauth2.SpotifyClientCredentials
CacheFileHandler = spotipy.cache_handler.CacheFileHandler

dz = Deezer()
settings = DEFAULT_SETTINGS
plugins = {}
stdout = open(sys.stdout.fileno(), 'wb')

class MockCache(dict):
    def __getitem__(self, _key):
        return {}

class SpotifyStreamer(Spotify):
    def __init__(self, id, secret, auth_cache):
        super().__init__(None)
        self.credentials = {
            "clientId": id,
            "clientSecret": secret,
        }
        self.auth_cache = auth_cache
    
    def setup(self):
        self.checkCredentials()
        return self

    def loadCache(self):
        return MockCache()

    def saveCache(self, _cache):
        pass
    
    def checkCredentials(self):
        if self.credentials['clientId'] == "" or self.credentials['clientSecret'] == "":
            self.enabled = False
            return

        try:
            cache_handler = CacheFileHandler(self.auth_cache)
            client_credentials_manager =SpotifyClientCredentials(
                client_id=self.credentials['clientId'],
                client_secret=self.credentials['clientSecret'],
                cache_handler=cache_handler
            )

            self.sp = spotipy.Spotify(client_credentials_manager=client_credentials_manager)
            self.sp.user_playlists('spotify')
            self.enabled = True
        except Exception:
            self.enabled = False

def start(downloadObject):
    if isinstance(downloadObject, Single):
        extraData = {
            'trackAPI': downloadObject.single.get('trackAPI'),
            'albumAPI': downloadObject.single.get('albumAPI')
        }
        wrapped_stream(downloadObject, extraData)

    elif isinstance(downloadObject, Collection):
        for track in downloadObject.collection['tracks']: 
            extraData = {
                'trackAPI': track,
                'albumAPI': downloadObject.collection.get('albumAPI'),
                'playlistAPI': downloadObject.collection.get('playlistAPI')   
            }
            wrapped_stream(downloadObject, extraData)


def wrapped_stream(downloadObject, extraData):
    trackAPI = extraData.get('trackAPI')
    json.dump(trackAPI, sys.stderr)
    print("", file=sys.stderr, end="\n")
    
    try:
        stream_stdout(downloadObject, extraData)
    except DownloadFailed as e:
        pass

    

def stream_stdout(downloadObject, extraData, track=None, bitrate=TrackFormats.MP3_320):
    trackAPI = extraData.get('trackAPI')
    albumAPI = extraData.get('albumAPI')
    playlistAPI = extraData.get('playlistAPI')

    if int(trackAPI['id']) == 0: raise DownloadFailed("notOnDeezer")
    if not track:
        try:
            track = Track().parseData(
                dz=dz,
                track_id=trackAPI['id'],
                trackAPI=trackAPI,
                albumAPI=albumAPI,
                playlistAPI=playlistAPI
            )
        except AlbumDoesntExists as e:
            raise DownloadError('albumDoesntExists') from e
        except MD5NotFound as e:
            raise DownloadError('notLoggedIn') from e

    # Check if track not yet encoded
    if track.MD5 == '': raise DownloadFailed("notEncoded", track)
    try:
        selectedFormat = getPreferredBitrate(
            dz,
            track,
            bitrate,
            DEFAULT_SETTINGS['fallbackBitrate'],
            DEFAULT_SETTINGS['feelingLucky'],
        )
    except WrongLicense as e:
        raise DownloadFailed("wrongLicense") from e
    except WrongGeolocation as e:
        raise DownloadFailed("wrongGeolocation", track) from e
    except PreferredBitrateNotFound as e:
        raise DownloadFailed("wrongBitrate", track) from e
    except TrackNot360 as e:
        raise DownloadFailed("no360RA") from e

    track.bitrate = selectedFormat
    track.album.bitrate = selectedFormat

    # Apply settings
    track.applySettings(DEFAULT_SETTINGS)
    track.downloadURL = track.urls[formatsName[track.bitrate]]    
    if not track.downloadURL: raise DownloadFailed('notAvailable', track)

    try:
        streamTrack(stdout, track, downloadObject=downloadObject)
    except requests.exceptions.HTTPError as e:
        raise DownloadFailed('notAvailable', track) from e


@click.command()
@click.option('-a', '--arl', type=str, default=None, help='ARL token to use')
@click.option('-s', '--spt-id', type=str, help='Path to the config folder')
@click.option('-ss', '--spt-secret', type=str, help='Path to the config folder')
@click.option('-sc', '--spt-cache', type=str, help='Path to the config folder')
@click.argument('url', nargs=-1, required=True)
def stream(url, arl, spt_id, spt_secret, spt_cache):
    assert arl, 'You must provide an ARL token'
    assert dz.login_via_arl(arl.strip()), 'Invalid ARL'

    settings = DEFAULT_SETTINGS
    
    plugins = {"spotify": SpotifyStreamer(spt_id, spt_secret, spt_cache)}
    plugins["spotify"].setup()
    
    bitrate = settings.get("maxBitrate", TrackFormats.MP3_320)
    (link, _link_type, _link_id) = parseLink(url[0])

    objects = []
    downloadObject = generateDownloadObject(dz, link, bitrate, plugins=plugins, listener=None)
    if isinstance(downloadObject, list):
        objects += downloadObject
    else:
        objects.append(downloadObject)
    
    for obj in objects:
        if obj.__type__ == "Convertable":
            obj = plugins[obj.plugin].convert(dz, obj, settings)
    
        start(obj)

    stdout.close()
    
if __name__ == '__main__':
    stream(auto_envvar_prefix='DEEMIX')